## Why `NodeJS & Typescript`

在项目的技术选型上我没有使用常规的 `Python` 和 `Java`，而是选用了基于 `Chrome V8` 引擎的 `NodeJS`。主要是看重了 `NodeJS` 天生的异步特性，因为该项目有大量的时间是在读写数据库，所以这样天生异步的特性在 `I/O` 密集的项目当中能发挥巨大的优势，大大缩短了项目的时间代价。而相比之下 `Python` 的多线程模块性能一直是大问题，所以放弃了 `Python`。而 `Java` 相比之下需要手动管理多个线程之间，在多线程、多进程公用的情况下提升了编程的代价，所以综合下选择了 `NodeJS`。

而相比 `Java`，`NodeJS` 的弱类型在项目开发中会为开发者埋下许多难以发下的 `bug`，并且在项目后期的维护性和可读性上都是比较差的。所以这里引入 `Javascript` 的超集 `Typescript`, 它添加了可选的静态类型和面向对象的编程方法。这样就弥补了 `NodeJS` 工程性上的缺陷。

## Why `Redis`

在项目中由于 `NodeJS` 对于多种内存的限制，引入 `Redis` 这种内存数据库进行补充。一是对内存边际的拓展，二是利用其实现好的 `sortedset` 类型来完成优秀的有序集合操作。

有序集合是项目中使用最频繁的功能，有一个快速操作能力的有序集合是对本项目性能最关键的一点。而 `Redis` 的 `sortedset` 使用跳跃表进行实现，与红黑树、AVL树等平衡树有基本相同的插入速度、查找速度。插入复杂度为 `O(M*log(N))`，`N` 是有序集的基数， `M` 为成功添加的新成员的数量。修改复杂度为 `O(log(N))`，查找复杂度为 `O(log(N))`。可见是非常优秀的实现方案。

## 画图方案

相比与常被用来做数据工作的 `Python`，`NodeJS` 的数据统计库较少，画图库更少。但是由于 `NodeJS` 是对浏览器 `Javascript` 的移植，有很好的 `canvas` 处理能力，所以可以直接对现目前最优秀的前端画图库 `echarts` 直接使用。所以本文中使用了 `node-canvas` 配合 `node-echarts` 的解决方案，可以看到无论从图标的可视性和丰富性上都远胜于别的语言的原生画图方案。

